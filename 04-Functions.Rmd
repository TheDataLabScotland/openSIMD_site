# Functions {#functions}

Below is some documentation of the novel functions developed for this project and used repeatedly throughout the openSIMD proceedure.

## normalScores {#normalScores}

The `normalScores` function is the first in the work flow. This calculates the normal scores for each indicator. The normal score is defined as follows:

\begin{equation*}
y_{i} = \phi^{-1} \frac{r_{i}}{n + 1} 
\end{equation*}

where: $\phi^{-1}$ is the inverse cumulative normal (probit) function, $r_{i}$ is the rank of the i'th observation and $n$ is the number of non-missing observations for the ranking variable. This is the inverse cumulative normal probability density of proportional ranks. The resulting variable should appear normally distributed regardless of the input data. We translated this approach using the [SAS documentation](http://support.sas.com/documentation/cdl/en/proc/61895/HTML/default/viewer.htm#a000146840.htm) as a guide resulting in the following R function.

```{r}
normalScores <- function(
  v,                  # a numeric vector as the input variable
  ties = "average",   # passed to ties.method argument in rank()
  forwards = TRUE     # smallest numerical value on left? default is TRUE 
) {
  
  r <- rank(v, ties.method = ties)
  n <- length(na.omit(v))
  
  rn <- r / (n + 1)
  
  y <- qnorm(rn, mean = 0, sd = 1, lower.tail = forwards)
  
  return(y)
  
}
```

The function takes a numeric vector as its input `v`. It first ranks this input `r` and then calculates the proportional rank `rn`. The final step is to apply the cumulative normal probability using the `qnorm` function. The return value is a numeric vector of the same length as the input `v`.

## replaceMissing {#replaceMissing}

A simple utility function to replace missing values, once normalised indicator scores have been calculated. A convenience wrapper around `replace`. The function find missing values (as well as `Inf` and `-Inf`) in a vector and replaces them with `0`. The use case is for example when a data zone is empty, has a missing value for an indicator but we want it to sit in the centre of the distribution and so we assign a value of 0.

```{r}
replaceMissing <- function(v) replace(v, is.na(v) | v == Inf | v == -Inf, 0)
```

Pass a numeric vector `v` and return a vector of equal length with missing values filled.

## getFAWeights {#getFAWeights}

This function performs a factor analysis using the `psych::fa` function. It then extracts the weights on the first resulting factor, converts then to poportions (of the sum of weights) and then returns them as individual elements of a list. This is designed to be equivalent to the SAS procedure in previous SIMD calculations, however the results are only comparable to two decimal places, likely due to differences in the implementation of factor analysis in the two packages (see [section on tests](#tests)).

```{r}
getFAWeights <- function(dat, ...) {
  
  fact <- psych::fa(dat, nfactors = 1, fm = "ml", rotate = "none", ...)
  
  f1_scores <- as.data.frame(fact$weights) %>% select(ML1)
  
  f1_weights <- f1_scores / sum(f1_scores)
  
  # This is just to make each weight an individual element of a list
  # For compatibility with purrr::map2() in the next step, combineWeightsAndNorms()
  return(lapply(seq_along(f1_weights$ML1), function(i) f1_weights$ML1[i]))

  }
```

The function takes a data frame `dat` as its main argument, it is assumed that this data frame contains all of the variables for factor analysis and in the required order. The return value is a list with individual elements corresponding to the proportional weight of variables in the same order as the input data. A list is returned here for compatibility with the next function `combineWeightsAndNorms` however this can be easily converted to a vector with `unlist`.

## combineWeightsAndNorms {#combineWeightsAndNorms}

This function takes the normalised indicator scores and the weights derived from factor analysis, multiplies them out and then takes the sum of these weighted indicator scores to get the final score for that domain. 

```{r}
combineWeightsAndNorms <- function(weights, norms) {
  
  combined <- purrr::map2(weights, norms, ~ .x * .y)
  
  combined %>% data.frame %>% rowSums
  
}
```

The function takes a list of weights (generated by `getFAWeights` and a data.frame of normalised scores, it 
returns a numeric vector containing the combined domain score.

## expoTransform {#expoTransform}

This function recapitulates the exponential transformation used in SIMD to transform the weighted domain ranks before combining domains. 

```{r}
expoTransform <- function(ranks) {
  
  prop_ranks <- ranks / max(ranks)

  expo <- -23 * log(1 - prop_ranks * (1 - exp( -100 / 23)))
  
  return(expo)
}
```

The function takes an numeric vector (of the ranks) and returns a numeric vector of equal length containing the transformed values.

## reassignRank {#reassignRank}

A function to make manual reassignments of ranks to individual data zones, can be used when there are strange exceptions such as empty data zones.

```{r}
reassignRank <- function(data, domain, data_zone, end = "max", offset = 0) {
  
  if(end == "max") {
    data[data$data_zone == data_zone, domain] <- 
      max(data[, domain], na.rm = TRUE) - (offset + 0.1)
  }else
    if(end == "min") {
      data[data$data_zone == data_zone, domain] <- 
        min(data[, domain], na.rm = TRUE) + (offset + 0.1)
    }
  
  data[, domain] <- rank(data[, domain])
  
  return(data)
}
```

The function needs a data.frame of ranks containing a collumn named 'data_zone'. The function will take that data.frame change the rank of the indicator in question (with an optional offset) and then re-rank. The function returns the corrected data.frame.
